# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18jHQYwKKjyDTG6uwsA7zvPKLr9jzcxSl
"""

import streamlit as st
import openrouteservice
from openrouteservice import convert
import folium
from streamlit_folium import st_folium
import requests

st.set_page_config(page_title="Rota Inteligente", layout="centered")
st.title("üöõ Roteirizador Inteligente com Redu√ß√£o de Custos")

# üìå Entradas
api_key = st.text_input("üîë API Key do OpenRouteService", type="password")
col1, col2 = st.columns(2)
with col1:
    origem_lat = st.number_input("Latitude de Origem", value=-23.5505)
    origem_lon = st.number_input("Longitude de Origem", value=-46.6333)
with col2:
    destino_lat = st.number_input("Latitude de Destino", value=-23.5640)
    destino_lon = st.number_input("Longitude de Destino", value=-46.6528)

custo_km = st.number_input("üí∏ Custo por km (R$)", value=2.5)

# üéØ Fun√ß√µes auxiliares

def consultar_chuva(lat, lon):
    """Consulta se est√° chovendo em uma coordenada usando a API p√∫blica do Open-Meteo."""
    url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current=precipitation"
    try:
        resp = requests.get(url, timeout=5)
        data = resp.json()
        chuva_mm = data.get("current", {}).get("precipitation", 0)
        return chuva_mm > 0
    except:
        return False  # fallback: assume sem chuva se erro

def calcular_risco(lat, lon, chovendo):
    """Simula risco baseado em localiza√ß√£o e chuva real."""
    hotspots = [
        (-23.555, -46.635),  # roubo
        (-23.560, -46.645),  # acidente
        (-23.565, -46.650),  # enchente
    ]
    risco = 0.0
    for hlat, hlon in hotspots:
        if abs(lat - hlat) < 0.01 and abs(lon - hlon) < 0.01:
            risco += 0.3
    if chovendo:
        risco += 0.2
    return min(risco, 1.0)

def calcular_risco_medio(coords):
    total = 0
    for lon, lat in coords:
        chovendo = consultar_chuva(lat, lon)
        total += calcular_risco(lat, lon, chovendo)
    return total / len(coords)

def calcular_score_final(dist_km, tempo_min, risco):
    base = dist_km * custo_km
    penalidade_risco = base * risco
    penalidade_tr√¢nsito = tempo_min * 0.1
    return base + penalidade_risco + penalidade_tr√¢nsito

# üîÑ Execu√ß√£o principal
if st.button("üöÄ Calcular Rota Ideal"):
    if not api_key:
        st.warning("‚ö†Ô∏è Insira uma chave v√°lida do OpenRouteService.")
    else:
        try:
            client = openrouteservice.Client(key=api_key)
            coords = [(origem_lon, origem_lat), (destino_lon, destino_lat)]
            rota = client.directions(coords)
            geo = convert.decode_polyline(rota['routes'][0]['geometry'])
            distancia_m = rota['routes'][0]['summary']['distance']
            duracao_s = rota['routes'][0]['summary']['duration']
            dist_km = distancia_m / 1000
            duracao_min = duracao_s / 60

            risco_medio = calcular_risco_medio(geo['coordinates'])
            custo_total = calcular_score_final(dist_km, duracao_min, risco_medio)

            # üó∫Ô∏è Mapa
            m = folium.Map(location=[origem_lat, origem_lon], zoom_start=13)
            folium.Marker([origem_lat, origem_lon], tooltip="Origem", icon=folium.Icon(color="green")).add_to(m)
            folium.Marker([destino_lat, destino_lon], tooltip="Destino", icon=folium.Icon(color="red")).add_to(m)
            folium.PolyLine(
                [(lat, lon) for lon, lat in geo['coordinates']],
                color="blue", weight=5
            ).add_to(m)

            # üßæ Resultados
            st_folium(m, width=700, height=500)
            st.markdown(f"""
            ### üìä Resultados da Rota
            - üõ£Ô∏è **Dist√¢ncia:** {dist_km:.2f} km
            - ‚è±Ô∏è **Tempo estimado:** {duracao_min:.1f} min
            - üåßÔ∏è **Chuva detectada:** {"Sim" if any(consultar_chuva(lat, lon) for lon, lat in geo['coordinates']) else "N√£o"}
            - ‚ö†Ô∏è **Risco m√©dio da rota:** {risco_medio:.2f}
            - üí∞ **Custo total estimado:** R$ {custo_total:.2f}
            """)

        except Exception as e:
            st.error(f"Erro ao calcular a rota: {e}")
